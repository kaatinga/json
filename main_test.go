package json

import (
	"reflect"
	"strconv"
	"testing"
)

// samples
var (
	jsonExample = []byte{ObjectStart, 0x22, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74, 0x22, 0x3a, 0x22, 0x31, 0x32, 0x33, 0x34, 0x35, 0x22, ObjectEnd}
	one2345     = []byte{0x31, 0x32, 0x33, 0x34, 0x35}
	secret      = []byte{0x73, 0x65, 0x63, 0x72, 0x65, 0x74}

	jsonPosNumber1 = []byte{0x7b, 0x22, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74, 0x22, 0x3a, 0x20, 0x31, 0x32, 0x33, 0x7d}
	jsonNegNumber1 = []byte{0x7b, 0x22, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74, 0x22, 0x3a, 0x20, 0x2d, 0x31, 0x32, 0x33, 0x7d}
	jsonFloatType1 = []byte{0x7b, 0x22, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74, 0x22, 0x3a, 0x20, 0x2d, 0x31, 0x32, 0x2e, 0x33, 0x7d}
)

//func TestScanner_validateToken(t *testing.T) {
//
//	tests := []struct {
//		name   string
//		data   []byte
//		sample []byte
//		want   bool
//	}{
//		{"ok", secret, secret, true},
//		{"!ok", []byte{0x73, 0x65, 0x63, 0x72, 0x65, 0x75}, secret, false},
//	}
//	for _, tt := range tests {
//		t.Run(tt.name, func(t *testing.T) {
//			s, err := NewScanner(tt.sample)
//			if err != nil {
//				t.Errorf("setSample error = %v, want nil", err)
//			}
//			got := s.validateToken()
//			if got != tt.want {
//				t.Errorf("validateToken() = %v, want %v", got, tt.want)
//			}
//		})
//	}
//}

func TestScanner_readData(t *testing.T) {

	tests := []struct {
		name    string
		scanner Scanner
		result  []byte
		wantErr bool
	}{
		{"ok", Scanner{
			position: 11,
			byte:     0,
			sample:   nil,
			data:     jsonExample,
		}, []byte{0x31, 0x32, 0x33, 0x34, 0x35}, false},
		{"ok", Scanner{
			position: 11,
			byte:     0,
			sample:   nil,
			data:     []byte{ObjectStart, 0x22, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74, 0x22, 0x3a, 0x22, 0x31, 0x32, 0x33, 0x34, 0x35, 0x21, ObjectEnd},
		}, nil, true},
		{"ok", Scanner{
			position: 11,
			byte:     0,
			sample:   nil,
			data:     []byte{ObjectStart, 0x22, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74, 0x22, 0x3a, 0x22, 0x31, 0x32, 0x33, 0x34, 0x35, 0x21},
		}, nil, true},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			s := &tt.scanner
			if err := s.readString(); (err != nil) != tt.wantErr {
				t.Errorf("readString() error = %v, wantErr %v", err, tt.wantErr)
			}

			if !reflect.DeepEqual(s.parsedData, tt.result) {
				t.Errorf("parsed data is incorrect\n have %v, want %v", s.parsedData, tt.result)
			}
		})
	}
}

func TestScanner_SetSample(t *testing.T) {

	tests := []struct {
		name    string
		scanner Scanner
		sample  []byte
		wantErr bool
	}{
		{"ok", Scanner{}, secret, false},
		{"!ok1", Scanner{}, []byte{}, true},
		{"!ok2", Scanner{}, nil, true},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			_, err := NewScanner(tt.sample)
			if (err != nil) != tt.wantErr {
				t.Errorf("SetSample() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}

func TestScanner_Seek(t *testing.T) {

	boolTrue := []byte{0x7b, 0x22, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74, 0x22, 0x3a, 0x74, 0x72, 0x75, 0x65, 0x2c, 0x20, 0x22, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x22, 0x3a, 0x22, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74, 0x22, 0x7d}
	boolFalse := []byte{0x7b, 0x22, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74, 0x22, 0x3a, 0x66, 0x61, 0x6c, 0x73, 0x65, 0x2c, 0x20, 0x22, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x22, 0x3a, 0x22, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74, 0x22, 0x7d}
	badBool := []byte{0x7b, 0x22, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74, 0x22, 0x3a, 0x74, 0x72, 0x75, 0x2c, 0x20, 0x22, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x22, 0x3a, 0x22, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74, 0x22, 0x7d}
	withNull := []byte{0x7b, 0x22, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74, 0x22, 0x3a, 0x6e, 0x75, 0x6c, 0x6c, 0x2c, 0x20, 0x22, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x22, 0x3a, 0x22, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74, 0x22, 0x7d}

	boolFalsePlusSecret := []byte{0x7b, 0x22, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x22, 0x3a, 0x66, 0x61, 0x6c, 0x73, 0x65, 0x2c, 0x20, 0x22, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74, 0x22, 0x3a, 0x22, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74, 0x22, 0x7d}
	secondValue := []byte{0x7b, 0x22, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x22, 0x3a, 0x74, 0x72, 0x75, 0x65, 0x2c, 0x20, 0x22, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74, 0x22, 0x3a, 0x22, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74, 0x22, 0x7d}

	badWhiteSpace := []byte{0x7b, 0x22, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74, 0x22, 0x3a, 0x6e, 0x75, 0x6c, 0x6c, 0x2c, 0x20, 0x22, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x22, 0x3a, 0x22, 0x31, 0x20, 0x32, 0x20, 0x33, 0x22, 0x7d}

	tests := []struct {
		name      string
		sample    []byte
		value     []byte
		boolValue bool
		data      []byte
		wantErr   error
	}{
		{"ok1", secret, one2345, false, jsonExample, nil},
		{"ok2", secret, secret, false, secondValue, nil},
		{"ok3", []byte("secret"), secret, false, boolFalsePlusSecret, nil},
		{"ok4", []byte("parameter"), []byte("1 2 3"), false, badWhiteSpace, nil},
		{"ok5", secret, nil, false, jsonPosNumber1, nil},
		{"ok_bool true", []byte("secret"), nil, true, boolTrue, WarnBoolWasFound},
		{"ok_bool false", []byte("secret"), nil, false, boolFalse, WarnBoolWasFound},
		{"!ok1", []byte("mmm"), nil, false, jsonExample, WarnNotFound},
		{"!ok2", []byte("mmm"), nil, false, []byte("mmmmm"), ErrInvalidJSON},
		{"!ok3", []byte("secr"), nil, false, jsonExample, WarnNotFound},
		{"!ok4", []byte("secr"), nil, false, jsonExample, WarnNotFound},
		{"!ok5", []byte("secret"), nil, false, badBool, ErrInvalidJSON},
		{"array", []byte("secret"), nil, false, []byte{'[', ']'}, ErrInvalidDataLength},
		{"null", []byte("secret"), nil, false, withNull, WarnNullWasFound},
		{"!ok6", nil, nil, false, jsonExample, ErrInvalidSampleLength},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			s, err := NewScanner(tt.sample)
			if err != nil {
				if err != tt.wantErr {
					t.Errorf("NewScanner() error, %s", err)
					t.FailNow()
				}
				return
			}

			err = s.SeekIn(tt.data)
			if err != tt.wantErr {
				t.Errorf("SeekIn() error is incorrect\nhave '%v'\nwant '%v'", err, tt.wantErr)
			}

			err = s.SeekIn(tt.data)
			if err != tt.wantErr {
				t.Errorf("Second SeekIn() error is incorrect\nhave '%v'\nwant '%v'", err, tt.wantErr)
			}

			if !reflect.DeepEqual(s.parsedData, tt.value) {
				t.Errorf("value:\nhave '%v'\nwant '%v'", string(s.parsedData), string(tt.value))
			}

			if s.parsedBool != tt.boolValue {
				t.Errorf("bool value:\nhave '%v'\nwant '%v'", s.parsedBool, tt.boolValue)
			}

			t.Log(string(s.data))

			if s.parsedNumber != 0 {
				t.Log(s.parsedNumber)
			}
		})
	}
}

func TestScanner_readNumber(t *testing.T) {

	tests := []struct {
		scanner      Scanner
		resultMustBe int
		wantErr      error
	}{
		{Scanner{
			position: 11,
			byte:     0,
			sample:   secret,
			data:     jsonPosNumber1,
		}, 123, nil},
		{Scanner{
			position: 11,
			byte:     0,
			sample:   secret,
			data:     jsonNegNumber1,
		}, -123, nil},
		{Scanner{
			position: 11,
			byte:     0,
			sample:   secret,
			data:     jsonFloatType1,
		}, -12, WarnFloatNotSupported},
	}
	for _, tt := range tests {
		t.Run(strconv.Itoa(tt.resultMustBe), func(t *testing.T) {
			s := &tt.scanner
			err := s.readNumber()
			if err != tt.wantErr {
				t.Errorf("readNumber() error = %v, wantErr %v", err, tt.wantErr)
			}

			if s.parsedNumber != int64(tt.resultMustBe) {
				t.Errorf("readNumber() result is incorrect\nhave %d\nwant %d", s.parsedNumber, tt.resultMustBe)
			}
		})
	}
}
